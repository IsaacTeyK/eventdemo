## Exercise 4: Create Smart Contract
Duration: 30 minutes

In this exercise, you will create a new Smart Contract that targets the Ethereum blockchain that is written in the Solidity programming language.

### Task 1: Code TelementryCompliance SmartContract
1. Open ** Visual Studio Code**, click **File** followed by **Open Folder...**
![](https://github.com/ceteongvanness/eventdemo/blob/master/Azure%20Blockchain%20Workshop/Image/D1.png)

2. In the **Open Folder** dialog, select the **C:\HOL** folder. (If the dolder does not exist yet, please create it.)
![](https://github.com/ceteongvanness/eventdemo/blob/master/Azure%20Blockchain%20Workshop/Image/D2.png)

3. Expand the **Explorer** pane, then hover over the **HOL** folder, and click the  **New File** button.
![](https://github.com/ceteongvanness/eventdemo/blob/master/Azure%20Blockchain%20Workshop/Image/D3.png)

4. Type in **TelemetryCompliance.sol** as the file name.
![](https://github.com/ceteongvanness/eventdemo/blob/master/Azure%20Blockchain%20Workshop/Image/D4.png)

5. Open the **TelemetryCompliance.sol** file, then add the following line to the top of the file. This first line specifies the source code is written for Solidity version 0.4.20 or newer that does not break functionality up to, but not including version 0.5.0. This is to ensure the Smart Contract does not behave differently with a new compiler version.
```
pragma solidity ^0.4.20;
```

6. Next, add the base contract for Blockchain Workbench, WorkbenchBase

When creating Smart Contracts, this base contract will capture the contract type and address, then log them as events. The type and address are passed into the base contract from the constructor, and the ContractCreated function is called from the constructor. As state changes, the contract will call the ContractUpdated function on the base contract to indicate an update has occured specifying the function in the contract that was called.
```
contract WorkbenchBase {
    event WorkbenchContractCreated(string applicationName, string workflowName, address originatingAddress);
    event WorkbenchContractUpdated(string applicationName, string workflowName, string action, address originatingAddress);

    string internal ApplicationName;
    string internal WorkflowName;

    function WorkbenchBase(string applicationName, string workflowName) internal {
        ApplicationName = applicationName;
        WorkflowName = workflowName;
    }

    function ContractCreated() internal {
        WorkbenchContractCreated(ApplicationName, WorkflowName, msg.sender);
    }

    function ContractUpdated(string action) internal {
        WorkbenchContractUpdated(ApplicationName, WorkflowName, action, msg.sender);
    }
}
```

7. Next, add the beginning of the Smart Contract. The type name for this contract will be TelemetryCompliance, and it will inherit from the WorkbenchBase base contract.
```
contract TelemetryCompliance is WorkbenchBase('TelemetryCompliance', 'TelemetryCompliance')
{
    // insert smart contract code here
}
```

8. Next, the functionality of the Smart Contract needs to be filled out. Start this by adding the following **enum StateType** definition within the **TelemetryCompliance** class.
```
enum StateType {
    Creating,
    Created,
    TransitionRequestPending,
    InTransit,
    FinalDelivery,
    Completed,
    OutOfCompliance
}
```

9. Add the **State** property of type **StateType**. This will be used through-out the lifetime of the Smart Contract to store the appropriate state of the contract.
```
StateType public State;
```

10. Add the following additional properties to the Smart Contract. These properties will be used to track the different individuals who will be participating in the workflow.
```
address public InitiatingCounterparty;
address public Counterparty;
address public PreviousCounterparty;
address public RequestedCounterparty;
address public Device;
address public SupplyChainOwner;
address public SupplyChainObserver;
```
The "**Counterparty**" properties that were added are used to reflect the different individuals' organizations that have had, do currently have, or are about to have possession of a package.

There is also a "**Device**" property to provide telemetry information on humidity and temperature which will evaluated by the Smart Contract. The contract is setup so that this can work with both a real device and Azure IoT Hub, or a person simulating the device as a logged in user.

The "**SupplyChainOwner**" represents the organization that is shipping the package through the supply chain.

The "**SupplyChainObeserver**" represents an organization that does not participate in the supply chain but may be monitoring it. An example of an observer could be a government agency.

**NOTE:** The SupplyChainObserver is included in the properties of the Smart Contract, but it's not being implemented in this lab.

11. 






